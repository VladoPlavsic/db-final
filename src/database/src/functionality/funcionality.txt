---------------------------------------------------------------------INSERT CLIENTS-----------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE insert_client(fio_p VARCHAR(100), tel_p VARCHAR(12), job_p VARCHAR(50), homeadress_p VARCHAR(50), salary_p numeric(9,2))
LANGUAGE plpgsql
AS $$
BEGIN
INSERT INTO clients (fio, tel, job, homeadress, salary, call_back) VALUES (fio_p, tel_p, job_p, homeadress_p, salary_p, true);
END;
$$;
---------------------------------------------------------------------ON INSERT CLIENTS-------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION on_insert_clients()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
FOR i IN 1..(SELECT count(id) FROM services) LOOP
INSERT INTO live VALUES(NEW.id, i, (SELECT id FROM statuses WHERE status LIKE 'call back'));
END LOOP;
RETURN NEW;
END;
$$;

CREATE TRIGGER on_insert_clients_trigger AFTER INSERT ON clients FOR EACH ROW EXECUTE PROCEDURE on_insert_clients();

-----------------------------------------------------------------------------UPDATE CLIENTS-----------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE update_client(client_id_p INTEGER, tel_p VARCHAR(12) DEFAULT NULL, job_p VARCHAR(50) DEFAULT NULL, homeadress_p VARCHAR(50) DEFAULT NULL, salary_p numeric(9,2) DEFAULT NULL)
LANGUAGE plpgsql
AS $$
BEGIN
CASE
WHEN tel_p IS NOT NULL
THEN
UPDATE clients SET tel = tel_p WHERE id = client_id_p;
WHEN job_p IS NOT NULL
THEN
UPDATE clients SET job = job_p WHERE id = client_id_p;
WHEN homeadress_p IS NOT NULL
THEN
UPDATE clients SET homeadress = homeadress_p WHERE id = client_id_p;
WHEN salary_p IS NOT NULL 
THEN
UPDATE clients SET salary = salary_p WHERE id = client_id_p;
ELSE
END CASE;
END;
$$;

------------------------------------------------------------------------------DELETE CLIENTS----------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE delete_client(client_id_p INTEGER)
LANGUAGE plpgsql
AS $$
BEGIN
DELETE FROM clients WHERE id = client_id_p;
END;
$$;










-----------------------------------------------------------------------------INSERT INTO SERVICES-------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION insert_service(service_p VARCHAR(20), service_description_p TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
AS $$
BEGIN
INSERT INTO services (service, service_description) VALUES (service_p, service_description_p);
RETURN TRUE;
EXCEPTION WHEN OTHERS THEN
RETURN FALSE;
END;
$$;

------------------------------------------------------------------------------ON INSERT INTO SERVICES----------------------------------------------------------------------------------------
CREATE  OR REPLACE FUNCTION on_insert_services()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE 
local_id INTEGER;
BEGIN
FOR local_id IN (SELECT id FROM clients) LOOP
INSERT INTO live VALUES(local_id, NEW.id, 2);
END LOOP;
RETURN NEW;
END;
$$;

CREATE TRIGGER on_insert_services_trigger AFTER INSERT ON services FOR EACH ROW EXECUTE FUNCTION on_insert_services();


----------------------------------------------------------------------------DELETE SERVICES----------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE delete_service(service_id_p INTEGER)
LANGUAGE plpgsql
AS $$
BEGIN
DELETE FROM services WHERE id = service_id_p;
END;
$$;









------------------------------------------------------------------------------UPDATE LIVE STATUS PROCEDURE-----------------------------------------------------------------------------------
CREATE  OR REPLACE PROCEDURE update_live_status(client_id_p INTEGER, service_id_p INTEGER, status_id_p INTEGER)
LANGUAGE plpgsql
AS $$
BEGIN
UPDATE live SET status_id = status_id_p WHERE client_id = client_id_p AND service_id = service_id_p;
END;
$$;


------------------------------------------------------------------------------ON UPDATE LIVE-------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION on_update_status_live()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
RAISE NOTICE 'FUNCTION IS CALLED AND THE AMOUT IS %',
(SELECT count(client_id) FROM live WHERE client_id = NEW.client_id AND status_id = (SELECT id FROM statuses WHERE status LIKE 'call back'));
CASE 
(SELECT count(client_id) FROM live WHERE client_id = NEW.client_id AND status_id = (SELECT id FROM statuses WHERE status LIKE 'call back'))
WHEN 0 THEN
UPDATE clients SET call_back = false WHERE id = NEW.client_id;
DELETE FROM live WHERE client_id = NEW.client_id;
RETURN NEW;
ELSE
UPDATE clients SET call_back = true WHERE id = NEW.client_id;
RETURN NEW;
END CASE;
END;
$$;


CREATE TRIGGER on_update_status_live_trigger AFTER UPDATE OF status_id ON live FOR EACH ROW EXECUTE FUNCTION on_update_status_live();




-----------------------------------------------------------------------------ADD USER GROUP------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE add_group(group_name VARCHAR(50))
LANGUAGE plpgsql
AS $$
BEGIN
CREATE ROLE group_name;
GRANT SELECT, UPDATE ON live, clients TO group_name;
GRANT SELECT ON statuses, services TO group_name;
GRANT EXECUTE ON on_update_status_live, update_live_status TO group_name;
END;
$$;

------------------------------------------------------------------------------ADD USER----------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE add_user(username VARCHAR(50), password VARCHAR(50), group_p VARCHAR(50))
LANGUAGE plpgsql
AS $$
BEGIN
execute  'CREATE ROLE ' ||username|| ' WITH LOGIN PASSWORD ''' ||password|| ''' IN GROUP ' ||group_p||;
END;
$$;

