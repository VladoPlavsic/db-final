---------------------------------------------------------------------INSERT CLIENTS-----------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE insert_client(fio_p VARCHAR(100), tel_p VARCHAR(12), job_p VARCHAR(50), homeadress_p VARCHAR(50), salary_p numeric(9,2))
LANGUAGE plpgsql
AS $$
BEGIN
INSERT INTO clients (fio, tel, job, homeadress, salary, call_back) VALUES (fio_p, tel_p, job_p, homeadress_p, salary_p, true);
END;
$$;
---------------------------------------------------------------------ON INSERT CLIENTS-------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION on_insert_clients()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
FOR i IN 1..(SELECT count(id) FROM services) LOOP
INSERT INTO live VALUES(NEW.id, i, (SELECT id FROM statuses WHERE status LIKE 'call back'));
END LOOP;
RETURN NEW;
END;
$$;

CREATE TRIGGER on_insert_clients_trigger AFTER INSERT ON clients FOR EACH ROW EXECUTE PROCEDURE on_insert_clients();

-----------------------------------------------------------------------------UPDATE CLIENTS-----------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE update_client(client_id_p INTEGER,fio_p VARCHAR(100) DEFAULT NULL ,tel_p VARCHAR(12) DEFAULT NULL, job_p VARCHAR(50) DEFAULT NULL, homeadress_p VARCHAR(50) DEFAULT NULL, salary_p numeric(9,2) DEFAULT NULL, call_back_p BOOLEAN DEFAULT NULL)
LANGUAGE plpgsql
AS $$
BEGIN
CASE
WHEN fio_p IS NOT NULL
THEN
UPDATE clients SET fio = fio_p WHERE id = client_id_p;
ELSE
END CASE;
CASE
WHEN tel_p IS NOT NULL
THEN
UPDATE clients SET tel = tel_p WHERE id = client_id_p;
ELSE
END CASE;
CASE
WHEN job_p IS NOT NULL
THEN
UPDATE clients SET job = job_p WHERE id = client_id_p;
ELSE
END CASE;
CASE
WHEN homeadress_p IS NOT NULL
THEN
UPDATE clients SET homeadress = homeadress_p WHERE id = client_id_p;
ELSE
END CASE;
CASE
WHEN salary_p IS NOT NULL 
THEN
UPDATE clients SET salary = salary_p WHERE id = client_id_p;
ELSE
END CASE;
CASE
WHEN call_back_p IS NOT NULL 
THEN
UPDATE clients SET call_back = call_back_p WHERE id = client_id_p;
ELSE
END CASE;
END;
$$;

------------------------------------------------------------------------------DELETE CLIENTS----------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE delete_client(client_id_p INTEGER)
LANGUAGE plpgsql
AS $$
BEGIN
DELETE FROM clients WHERE id = client_id_p;
END;
$$;










-----------------------------------------------------------------------------INSERT INTO SERVICES-------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION insert_service(service_p VARCHAR(20), service_description_p TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
AS $$
BEGIN
INSERT INTO services (service, service_description) VALUES (service_p, service_description_p);
RETURN TRUE;
EXCEPTION WHEN OTHERS THEN
RETURN FALSE;
END;
$$;

------------------------------------------------------------------------------ON INSERT INTO SERVICES----------------------------------------------------------------------------------------
CREATE  OR REPLACE FUNCTION on_insert_services()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE 
local_id INTEGER;
BEGIN
FOR local_id IN (SELECT id FROM clients) LOOP
INSERT INTO live VALUES(local_id, NEW.id, 2);
END LOOP;
RETURN NEW;
END;
$$;

CREATE TRIGGER on_insert_services_trigger AFTER INSERT ON services FOR EACH ROW EXECUTE FUNCTION on_insert_services();


----------------------------------------------------------------------------DELETE SERVICES----------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE delete_service(service_id_p INTEGER)
LANGUAGE plpgsql
AS $$
BEGIN
DELETE FROM services WHERE id = service_id_p;
END;
$$;





---------------------------------------------------------------------------------GET ID's FOR UPDATE LIVE-----------------------------------------------------------
CREATE OR REPLACE FUNCTION get_id_for_update(client_name VARCHAR(100), client_number VARCHAR(12), service_name VARCHAR(50), status_name VARCHAR(20))
RETURNS TABLE (
    client_id INTEGER,
    service_id INTEGER,
    status_id INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    client INTEGER;
    service INTEGER;
    status INTEGER;
BEGIN
SELECT INTO client clients.id FROM clients WHERE clients.fio LIKE client_name AND clients.tel LIKE client_number;
SELECT INTO service services.id FROM services WHERE services.service LIKE service_name;
SELECT INTO status statuses.id FROM statuses WHERE statuses.status LIKE status_name;
RETURN QUERY SELECt client, service, status;
END;
$$;

/*
SELECT clients.id FROM clients WHERE clients.fio LIKE 'Vlado' AND clients.tel LIKE '+79685127157';
SELECT services.id FROM services WHERE services.service LIKE 'CREDIT';
SELECT statuses.id FROM statuses WHERE statuses.status LIKE 'no';
*/



------------------------------------------------------------------------------UPDATE LIVE STATUS PROCEDURE-----------------------------------------------------------------------------------
CREATE  OR REPLACE PROCEDURE update_live_status(client_id_p INTEGER, service_id_p INTEGER, status_id_p INTEGER)
LANGUAGE plpgsql
AS $$
BEGIN
UPDATE live SET status_id = status_id_p WHERE client_id = client_id_p AND service_id = service_id_p;
END;
$$;


------------------------------------------------------------------------------ON UPDATE LIVE-------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION on_update_status_live()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
RAISE NOTICE 'FUNCTION IS CALLED AND THE AMOUT IS %',
(SELECT count(client_id) FROM live WHERE client_id = NEW.client_id AND status_id = (SELECT id FROM statuses WHERE status LIKE 'call back'));
CASE 
(SELECT count(client_id) FROM live WHERE client_id = NEW.client_id AND status_id = (SELECT id FROM statuses WHERE status LIKE 'call back'))
WHEN 0 THEN
UPDATE clients SET call_back = false WHERE id = NEW.client_id;
DELETE FROM live WHERE client_id = NEW.client_id;
RETURN NEW;
ELSE
UPDATE clients SET call_back = true WHERE id = NEW.client_id;
RETURN NEW;
END CASE;
END;
$$;


CREATE TRIGGER on_update_status_live_trigger AFTER UPDATE OF status_id ON live FOR EACH ROW EXECUTE FUNCTION on_update_status_live();




-----------------------------------------------------------------------------ADD USER GROUP------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE add_group(group_name VARCHAR(50))
LANGUAGE plpgsql
AS $$
BEGIN
CREATE ROLE group_name;
execute 'CREATE ROLE ' ||group_name;
execute 'GRANT SELECT, UPDATE ON live, clients TO ' ||group_name;
execute 'GRANT DELETE ON live TO ' ||group_name;
execute 'GRANT SELECT ON statuses, services TO ' ||group_name; 
execute 'GRANT SELECT ON managers_view, managers_live_view TO ' ||group_name;
END;
$$;

------------------------------------------------------------------------------ADD USER----------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE add_user(username VARCHAR(50), password VARCHAR(50), group_p VARCHAR(50))
LANGUAGE plpgsql
AS $$
BEGIN
execute  'CREATE ROLE ' ||username|| ' WITH LOGIN PASSWORD ''' ||password|| ''' IN GROUP ' ||group_p||;
END;
$$;



------------------------------------------------------------------------------CHECK IF SUPERUSER--------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION is_super() RETURNS BOOLEAN
LANGUAGE plpgsql
AS $$
BEGIN
RETURN (SELECT usesuper FROM pg_user WHERE usename = CURRENT_USER);
END;
$$;



-------------------------------------------------------------------------CREATE VIEW FOR MANAGERS---------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION managers_view_function()
RETURNS TABLE (
    fio_p VARCHAR(100),
    tel_p VARCHAR(12),
    homeadress_p VARCHAR(100),
    salary_p NUMERIC(9,2)
)
LANGUAGE plpgsql
AS $$
BEGIN
RETURN QUERY SELECT fio, tel, homeadress, salary FROM clients WHERE call_back = true ORDER BY id;
END;
$$;

CREATE OR REPLACE VIEW managers_view AS
SELECT * FROM managers_view_function();


/*
CREATE OR REPLACE FUNCTION create_table_for_view(t_name VARCHAR(30))
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
EXECUTE format('
CREATE TABLE IF NOT EXISTS %I (
    fio_p VARCHAR(100),
    tel_p VARCHAR(12),
    adress_p VARCHAR(50),
    salary_p NUMERIC(9,2)
)', t_name);
FOR i IN 1..(SELECT count(id) FROM services) LOOP
EXECUTE format('ALTER TABLE %I ADD COLUMN IF NOT EXISTS %I VARCHAR(30)', t_name, (SELECT service FROM services WHERE id = i));
END LOOP;
END;
$$;
*/

CREATE OR REPLACE VIEW managers_live_view AS
SELECT status FROM statuses INNER JOIN live ON id = status_id ORDER BY client_id, service_id;



--------------------------------------------------------------TODAYS UPDATES


CREATE OR REPLACE VIEW administrator_client_view AS
SELECT * FROM clients ORDER BY id;


/*LIST ALL NON SUPERUSERS*/

CREATE OR REPLACE VIEW administrator_user_view AS
SELECT usename FROM pg_catalog.pg_user WHERE usesuper = false ORDER BY usename desc;

/*LIST ALL SERVICES*/

CREATE OR REPLACE VIEW administrator_service_view AS
SELECT * FROM services ORDER BY id;
